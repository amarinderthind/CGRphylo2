% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distances_and_export.R
\name{parallelCGR}
\alias{parallelCGR}
\title{Parallel computation of CGR frequency matrices}
\usage{
parallelCGR(sequences, k_mer, len_trim, num_cores = NULL)
}
\arguments{
\item{sequences}{List. A list of DNA sequences (from fastafile_new or similar).}

\item{k_mer}{Integer. The k-mer size for frequency calculation.}

\item{len_trim}{Integer. Length to trim all sequences to.}

\item{num_cores}{Integer. Number of CPU cores to use. If NULL, uses
detectCores() - 1.}
}
\value{
Named list. A list of frequency matrices, one per sequence.
}
\description{
Efficiently calculates CGR frequency matrices for multiple sequences using
parallel processing.
}
\details{
This function uses parallel processing to speed up the calculation of CGR
frequency matrices for large datasets. It automatically detects available
cores and leaves one free to prevent system freezing.

Note: On Windows, parallel processing falls back to sequential processing.
}
\examples{
\dontrun{
library(seqinr)
fasta <- read.fasta("sequences.fasta", seqtype = "DNA", as.string = TRUE)
filtered <- fastafile_new(fasta, N_filter = 50)

freq_mats <- parallelCGR(filtered, k_mer = 6, len_trim = 29000)
}

}
